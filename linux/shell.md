# Shell

Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂载、停止甚至是编写一些程序

Shell 还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。Shell 是解释执行的脚步语言，在 Shell 中可以直接调用 Linux 系统命令

## Shell 的分类

语法类型：

- Bourne Shell: 从 1979 起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh
- C Shell: C Shell 主要在 BSD 版的 Unix 系统中使用，其语法和 C 语言类似而得名

Shell 的两种主要语法类型有 Bourne 和 C，这两种语法彼此不兼容。Bourne 家族主要包括 sh, ksh, Bash, psh, zsh。 C 家族主要包括 csh, tcsh

检测当前系统用的是什么 Shell:

```bash
echo $SHELL
```

Bash: Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell。可以查看 /etc/shells 查看 Linux 支持的 Shell

## echo 输出命令

```bash
echo [选项] [输出内容]
```

选项：

- -e: 支持反斜线控制的字符转换(mac 可以省略)

| 控制字符 | 作用 |
| ---- | --- |
| \a | 输出警告音 |
| \b | 退格键，就是想做删除键 |
| \n | 换行符 |
| \r | 回车键 |
| \t | 制表符，也就是 Tab 键 |
| \v | 垂直制表符 |
| \0nnn | 按照八进制 ASCLL 码表输出字符。其中0为数字零，nnn为三位八进制数 |
| \xhh | 按照十六进制 ASCLL 码表输出字符。其中 hh 是两位十六进制数 |

颜色输出：

```bash
echo -e "\e[1;31m嫁人就要嫁\e[0m"
# \e[1; 开启颜色， \e[0m 关闭颜色
```

- 30m: 黑色
- 31m: 红色
- 32m: 绿色
- 33m: 黄色
- 34m: 蓝色
- 35m: 洋红色
- 36m: 青色
- 37m: 白色

## Shell 脚本执行

编写第一个脚本，编写 hello.sh

```bash
#!/bin/bash
# the first program

echo "hello world"
```

脚本执行方式：

- 赋予执行权限，直接运行
  - chmod 755 hello.sh
  - ./hello.sh
- 通过Bash调用执行脚本
  - bash hello.sh

## Bash 的基本功能

- 命令别名与快捷键
- 历史命令
- 输出重定向
- 多命令顺序执行
- Shell中特殊符号

### 别名查看与设置

```bash
# 查看本机已经设置的别名
alias

# 设置别名，临时生效
alias ls='ls --color=never'

# 永久生效别名
vi ~/.bashrc # 增加别名
source ~/.bashrc

# 临时删除别名
unalias [别名]
```

命令生效顺序：

1. 第一顺位执行用绝对路径或相对路径执行的命令
2. 第二顺位执行别名
3. 第三顺位执行 Bash 的内部命令
4. 第四顺位执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令

#### 常用快捷键

- ctrl+c: 强制终止当前命令
- ctrl+l: 清屏
- ctrl+a: 光标移动到命令行首
- ctrl+e: 光标移动到命令行尾
- ctrl+u: 从光标所在位置删除到行首
- ctrl+z: 把命令放入后台
- ctrl+r: 在历史命令中搜索

## 历史命令

```bash
history [选项] [历史命令保存文件]

history

# 默认的历史命令保存 1000 条，可以修改 /etc/profile
```

选项：

- -c: 清空历史命令
- -w: 把缓存中的历史命令写入历史命令问价 ~/.bash_history

历史命令的调用：

- 使用上下箭头调用以前的历史命令
- 使用 !n 重复执行第 n 条历史命令
- 使用 !! 重复执行上一条命令
- 使用 !字符串 重复执行最后一条以该字符串开头的命令

## 输出重定向

### 标准输入输出

| 设备 | 设备文件名 | 文件描述符 | 类型 |
| ---- | -------- | -------- | ---- |
| 键盘 | /dev/stdin | 0 | 标准输入 |
| 显示器 | /dev/stdout | 1 | 标准输出 |
| 显示器 | /dev/stderr | 2 | 标准错误输出 |

### 输出重定向

| 类型 | 符号 | 作用 |
| ---- | ---- | ---- |
| 标准输出重定向 | 命令 > 文件 | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中 |
| 标准输出重定向 | 命令 >> 文件 | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中 |
| 标准错误输出重定向 | 错误命令 2> 文件 | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中 |
| 标准错误输出重定向 | 错误命令 2>> 文件 | 以追加的方式，把命令的错误输出输出到指定的文件或设备当中 |
| 正确输出和错误输出同时保存 | 命令 > 文件 2>&1 | 以覆盖的方式，把命令的正确输出和错误输出都保存到指定的文件或设备当中 |
| 正确输出和错误输出同时保存 | 命令 >> 文件 2>&1 | 以追加的方式，把命令的正确输出和错误输出都保存到指定的文件或设备当中 |
| 正确输出和错误输出同时保存 | 命令 &> 文件 | 以覆盖的方式，把命令的正确输出和错误输出都保存到指定的文件或设备当中 |
| 正确输出和错误输出同时保存 | 命令 &>> 文件 | 以追加的方式，把命令的正确输出和错误输出都保存到指定的文件或设备当中 |
| 正确输出和错误输出同时保存 | 命令 >> 文件1 2>>文件2 | 把正确的输出追加到文件1中，把错误的输出追加到文件2中 |

## 输入重定向

```bash
# ctrl + d 退出
wc [选项] [文件名]
```

选项：

- -c: 统计字节数
- -w: 统计单词数
- -l: 统计行数

输入重定向：

- 命令 < 文件: 把文件作为命令的输入
- 命令 << 标识符: 标识符把标识符之间的内容作为命令的输入

```bash
# 将文件作为输入，交给 wc 处理，当然这里不加 < 也可以
wc < test.log

# 将 test 作为标记，当输入内容为 test 时，退出输入
wc << test
```

## 管道符

### 多命令顺序执行

| 多命令执行符 | 格式 | 作用 |
| ---------- | ---- | --- |
| ; | 命令1; 命令2 | 多个命令顺序执行，命令之间没有任何逻辑关系 |
| && | 命令1 && 命令2 | 逻辑与，当命令1正确执行，则命令2才会执行 |
| || | 命令1 || 命令2 | 逻辑或，当命令1执行不正确，则命令2才会执行，当命令1正确执行，则命令2不会执行 |

### 管道符

```bash
命令1 | 命令2
# 命令 1 的正确输出作为命令 2 的操作对象

netstat -an | grep ESTABLISHED | wc -l
```

## 通配符

| 通配符 | 作用 |
| ----- | ---- |
| ? | 匹配一个任意字符 |
| * | 匹配0个或多个任意字符，就是可以匹配任何内容 |
| [] | 匹配括号中任意一个字符。例如 [abc] 代表一定匹配一个字符，或者是a，或者是b，或者是c |
| [-] | 匹配括号中任意一个字符，- 代表一个范围，例如 [a-z] |
| [^] | 逻辑非，代表匹配不是括号内的一个字符 |


### Bash 中其他特殊符号

| 符号 | 作用 |
| --- | ---- |
| '' | 单引号。在单引号中所有的特殊符号，如 '$' 和 '`'（反引号）都没有特殊含义 |
| "" | 双引号。在双引号中部分特殊符号没有特殊含义，但是 '$' '`' 和 '\' 是例外 |
| \`\` | 反引号。反引号扩起来的内容是系统命令，在 Bash 中会先执行它。和 $() 作用一样，更推荐使用 $() |
| $() | 和反引号作用一样，用来引用系统命令 |
| # | 在 Shell 脚本中，# 开头的代表注释 |
| $ | 用于调用变量的值。例如需要调用变量 name 的值时，需要用 $name 的方式得到变量的值 |
| \ | 转义符，跟在 \ 之后的特殊符号将失去特殊意义，变为普通字符 |

```bash
# 定义 test 变量
test=123

echo test # test
echo $test # 123
echo '$test' # test 当作字符串输出
echo "$test" # 123 当作变量输出

aa=`ls` # aa 拿到的是系统命令 ls 执行后的结果
echo $aa
```