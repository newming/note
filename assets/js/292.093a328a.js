(window.webpackJsonp=window.webpackJsonp||[]).push([[292],{658:function(t,a,s){"use strict";s.r(a);var e=s(40),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),s("p",[t._v("React 是由 "),s("code",[t._v("facebook")]),t._v(" 推出，当下前端最流行的开源框架，学好 React 势在必行。")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/",target:"_blank",rel:"noopener noreferrer"}},[t._v("hooks 各种问题汇总"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/DLN9jjkAhJSJHksos_t43A",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Hooks 使用误区，驳官方文档"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/7085542534943883301",target:"_blank",rel:"noopener noreferrer"}},[t._v("React 全家桶汇总"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://blog.logrocket.com/how-to-use-svgs-in-react/",target:"_blank",rel:"noopener noreferrer"}},[t._v("How to use SVGs in React"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://segmentfault.com/a/1190000030696292",target:"_blank",rel:"noopener noreferrer"}},[t._v("react 中实现动画"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6922595635396870152",target:"_blank",rel:"noopener noreferrer"}},[t._v("rc-field-form实现"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://juejin.cn/post/6897038502517555207",target:"_blank",rel:"noopener noreferrer"}},[t._v("rc-field-form实现"),s("OutboundLink")],1)])]),t._v(" "),s("h2",{attrs:{id:"目录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目录"}},[t._v("#")]),t._v(" 目录")]),t._v(" "),s("ul",[s("li",[s("RouterLink",{attrs:{to:"/react/jsx.html"}},[t._v("jsx")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/react/reduxguide.html"}},[t._v("redux guide")])],1),t._v(" "),s("li",[s("RouterLink",{attrs:{to:"/react/vdom.html"}},[t._v("vdom")])],1)]),t._v(" "),s("h2",{attrs:{id:"react-hooks-为啥不能放在-if-中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-为啥不能放在-if-中"}},[t._v("#")]),t._v(" react hooks 为啥不能放在 if 中")]),t._v(" "),s("p",[t._v("react 是根据 useState 出现的顺序来定的，react 规定我们必须把 hooks 写在函数的最外层，不能写在 ifelse 等条件语句当中，来确保 hooks 的执行顺序一致")]),t._v(" "),s("h2",{attrs:{id:"reactnode-和-reactelement-的差异"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reactnode-和-reactelement-的差异"}},[t._v("#")]),t._v(" ReactNode 和 ReactElement 的差异")]),t._v(" "),s("div",{staticClass:"language-ts line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-ts"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactElement"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("P")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" JSXElementConstructor"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" JSXElementConstructor"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("any")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  props"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("P")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactText")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("number")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactChild")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" ReactElement "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" ReactText"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactNodeArray")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Array")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ReactNode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactFragment")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" ReactNodeArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ReactNode")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" ReactChild\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" ReactFragment\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" ReactPortal\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("boolean")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("undefined")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br"),s("span",{staticClass:"line-number"},[t._v("22")]),s("br"),s("span",{staticClass:"line-number"},[t._v("23")]),s("br")])]),s("h2",{attrs:{id:"函数组件和类组件的相同点和不同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数组件和类组件的相同点和不同点"}},[t._v("#")]),t._v(" 函数组件和类组件的相同点和不同点")]),t._v(" "),s("h3",{attrs:{id:"相同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点")]),t._v(" "),s("ul",[s("li",[t._v("它们都可以接收属性并且返回 React 元素")])]),t._v(" "),s("h3",{attrs:{id:"不同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[t._v("#")]),t._v(" 不同点")]),t._v(" "),s("ul",[s("li",[t._v("编程思想不同: 类组件需要创建实例，是基于面向对象的方式编程，而函数式组件不需要创建实例，接收输入，返回输出，是基于函数式编程的思路来编写的")]),t._v(" "),s("li",[t._v("内存占用：类组件需要创建并保存实例，会占用一定内存，函数组件不需要创建实例，可以节约内存占用")]),t._v(" "),s("li",[t._v("捕获特性：函数组件具有值捕获特性")]),t._v(" "),s("li",[t._v("可测试性: 函数式组件更方便编写单元测试")]),t._v(" "),s("li",[t._v("状态: 类组件有自己的实例，可以定义状态，而且可以修改状态更新组件，函数式组件以前没有状态，现在可以使用 useState 使用状态")]),t._v(" "),s("li",[t._v("生命周期: 类组件有自己完整的生命周期，可以在生命周期内编写逻辑，函数组件以前没有生命周期，现在可以使用 useEffect 实现类似生命周期的功能")]),t._v(" "),s("li",[t._v("逻辑复用: 类组件可以通过继承实现逻辑的复用，但官方推荐组合优于继承，函数组件可以通过自定义 Hooks 实现逻辑的复用")]),t._v(" "),s("li",[t._v("跳过更新: 类组件可以通过 shouldComponentUpdate 和 PureComponent 来跳过更新，而函数式组件可以使用 React.memo 来跳过更新")]),t._v(" "),s("li",[t._v("发展前景: 未来函数式组件将会成为主流，因为它可以更好的屏蔽 this 问题、规范和复用逻辑、更好的适合时间分片和并发渲染")])]),t._v(" "),s("h2",{attrs:{id:"react18-新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react18-新特性"}},[t._v("#")]),t._v(" react18 新特性")]),t._v(" "),s("ul",[s("li",[t._v("新的 render API，createRoot 等")]),t._v(" "),s("li",[t._v("setState 自动批处理，性能优化。批处理是一个破坏性改动，如果你想退出批量更新，可以使用 flushSync")]),t._v(" "),s("li",[t._v("组件返回值支持了 undefined，不在报错")]),t._v(" "),s("li",[t._v("Suspense 不再需要 fallback 来捕获")])]),t._v(" "),s("h3",{attrs:{id:"concurrent-mode（并发模式）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-mode（并发模式）"}},[t._v("#")]),t._v(" Concurrent Mode（并发模式）")]),t._v(" "),s("h2",{attrs:{id:"优化手段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化手段"}},[t._v("#")]),t._v(" 优化手段")]),t._v(" "),s("p",[t._v("对于正常的项目优化，一般都涉及到几个方面，开发过程中、上线之后的首屏、运行过程的状态")]),t._v(" "),s("ul",[s("li",[t._v("首屏优化一般涉及到几个指标 FP、FCP、FMP;要有一个良好的体验是尽可能的把 FCP 提前，需要做一个工程化处理，去优化资源的加载")]),t._v(" "),s("li",[t._v("方式以及分包策略，资源的减少是最有效的加快首屏打开的方式")]),t._v(" "),s("li",[t._v("对于 CSR 的应用，FCP 的过程一般是首先加载 js 与 css 资源，js 在本地执行完成，然后加载数据回来，做内容初始化渲染，这中间就有几次的网络反复请求的过程；所以 CSR 可以考虑使用骨架屏以及预渲染(部分结构预渲染)、suspence 与 lazy 做懒加载动态组件的方式")]),t._v(" "),s("li",[t._v("当然还有另外一种方式就是 ssr 的方式，ssr 对于首屏的优化有一定的优势，但是这种瓶颈一般在 node 服务器端的处理，建议使用 stream 流的方式来处理，对于体验与 node 端的内存管理等都有优势")]),t._v(" "),s("li",[t._v("不管对于 CSR 或 SSR，都建议配合使用 Service worker，来控制资源的调配以及骨架屏秒开的体验")]),t._v(" "),s("li",[t._v("react 项目上线后，首先需要保障的是可用性，所以可以通过 React.Profiler 分析组件的渲染次数以及好事的一些任务，但是 Profile 记录的是 commit 阶段的数据，所以对于 react 的调和阶段就需要结合 performance API 一起分析")]),t._v(" "),s("li",[t._v("由于 React 是父级 props 改变之后，所有与 props 不相关子组件在没有添加条件控制的情况下，也会触发 render 渲染，这是没有必要的，可以结合 React 的 PureComponent 以及 React.memo 等做浅比较处理，当然也可以结合使用 ShouldComponentUpdate 做深比较处理")]),t._v(" "),s("li",[t._v("所有的运行状态优化，都是减少不必要的 render，React.mome 与 React.callback 也是可以做很多优化的地方")]),t._v(" "),s("li",[t._v("在很多应用中，都会涉及到使用 redux 以及在使用 context，这两个都可能造成许多不必要的 render，在使用的时候，也需要谨慎的处理一些数据；")]),t._v(" "),s("li",[t._v("最后就是保证整个应用的可用性，为组件创建错误边界，可以使用 componentDidCatch 来处理")]),t._v(" "),s("li",[t._v("保证数据的不可变性")]),t._v(" "),s("li",[t._v("使用唯一的键值迭代")]),t._v(" "),s("li",[t._v("使用 web worker 做密集型的任务处理")]),t._v(" "),s("li",[t._v("不在 render 中处理数据")]),t._v(" "),s("li",[t._v("不必要的标签，使用 React.Fragment")])])])}),[],!1,null,null,null);a.default=r.exports}}]);