(window.webpackJsonp=window.webpackJsonp||[]).push([[295],{665:function(o,s,t){"use strict";t.r(s);var a=t(40),e=Object(a.a)({},(function(){var o=this,s=o.$createElement,t=o._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[t("h1",{attrs:{id:"hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[o._v("#")]),o._v(" hooks")]),o._v(" "),t("h2",{attrs:{id:"react-hooks-解决了什么问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-解决了什么问题"}},[o._v("#")]),o._v(" React Hooks 解决了什么问题")]),o._v(" "),t("p",[o._v("React Hooks 是 React16.8 新增特性，它的出现主要是为了解决状态逻辑复用，设计的主要业务场景如下:")]),o._v(" "),t("ul",[t("li",[o._v("复杂组件的状态和操作逻辑分散在各个生命周期中，难以维护；hooks 可以整合关联的处理逻辑到同一函数，各个关联逻辑可根据各自的状态的更新而触发函数执行")]),o._v(" "),t("li",[o._v("组件之间相同的操作无法复用，而 render props 和 HOC 高阶组件在解决复用问题同时却导致了组件树层级过深；使用自定义 hooks 能让开发人员无需改变组件结构也能复用逻辑处理")]),o._v(" "),t("li",[o._v("大量的使用 class 组件使 react 的编译特性无法发挥出来；使用 hooks 可以在不编写 class 的情况下使用 state 以及其他的 React 特性")]),o._v(" "),t("li",[o._v("函数组件没有状态和生命周期，函数组件无法处理数据或其他复杂逻辑，主要是基于传入的 props 来更新视图；使用 hooks 让函数组件拥有自己的状态，能独立处理逻辑")]),o._v(" "),t("li",[o._v("类组件在使用中存在 this 指向、难以压缩导致的性能问题；hooks 能使用 react 的特性通过是避免使用 class 导致的问题")]),o._v(" "),t("li",[o._v("React Hooks 更容易将组件的 UI 与状态分离，多个状态不会产生嵌套，写法还是比较平面----renderProps 可以通过 compose 解决，但是强制封装一个新对象增加实体数量，并且用法比较繁琐")]),o._v(" "),t("li",[o._v("Hooks 可以引用其他 Hooks。Hooks 函数必须以 use 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHooks 语句")])]),o._v(" "),t("h2",{attrs:{id:"react-怎么管理区分-hooks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-怎么管理区分-hooks"}},[o._v("#")]),o._v(" React 怎么管理区分 Hooks")]),o._v(" "),t("p",[o._v("React 通过单链表来管理 Hooks")]),o._v(" "),t("p",[o._v("按 Hooks 的执行顺序依次将 Hooks 节点添加到链表中")]),o._v(" "),t("p",[o._v("同时使用一张循环链表来记录每一次的更新操作")])])}),[],!1,null,null,null);s.default=e.exports}}]);