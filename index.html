<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>ceshi</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    #container {
      height: 100vh;
      overflow: auto;
    }
  </style>
</head>

<body>
  <div id='container'>
    <div id='box'>
    </div>
  </div>
  <script>
    // bind 兼容写法
    // if (!Function.prototype.testbind) {
    //   Function.prototype.testbind = function (oThis) {
    //     console.log(this)
    //     if (typeof this !== 'function') {
    //       // closest thing possible to the ECMAScript 5
    //       // internal IsCallable function
    //       throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    //     }

    //     var aArgs = Array.prototype.slice.call(arguments, 1),
    //       fToBind = this,
    //       fNOP = function () { },
    //       fBound = function () {
    //         console.log(this instanceof fNOP)
    //         return fToBind.apply(this instanceof fNOP
    //           ? this
    //           : oThis,
    //           // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
    //           aArgs.concat(Array.prototype.slice.call(arguments)));
    //       };
    //     // 维护原型关系
    //     if (this.prototype) {
    //       // Function.prototype doesn't have a prototype property
    //       fNOP.prototype = this.prototype;
    //     }
    //     fBound.prototype = new fNOP();
    //     // console.log(this instanceof fNOP)

    //     return fBound;
    //   };
    // }

    // var foo = function () {
    //   this.b = 100
    //   return this.a
    // }

    // var func = foo.testbind({a: 1})

    // // console.log(func())
    // console.log(new func())

    // function parenthesesChecker (symbols) {
    //   const stack = []
    //   const opens = '([{'
    //   const closers = ')]}'
    //   let balanced = true
    //   let index = 0
    //   let symbol
    //   let top

    //   while (index < symbols.length && balanced) {
    //     symbol = symbols[index]
    //     if (opens.indexOf(symbol) >= 0) {
    //       stack.push(symbol)
    //     } else if (stack.length === 0) {
    //       balanced = false
    //     } else {
    //       top = stack.pop()
    //       if (!(opens.indexOf(top) === closers.indexOf(symbol))) {
    //         balanced = false
    //       }
    //     }
    //     index++
    //   }
    //   return balanced && !stack.length
    // }
    // console.log(parenthesesChecker('()'))

    function swap(array, a, b) {
      /* const temp = array[a];
      array[a] = array[b];
      array[b] = temp; */
      [array[a], array[b]] = [array[b], array[a]];
    }

    function partition(array, left, right) {
      const pivot = array[Math.floor((right + left) / 2)]; // 取数组中间值
      let i = left; // 左右指针
      let j = right;

      while (i <= j) {
        while (array[i] < pivot) {
          i++; // 如果左边的指针的值小于中间值，符合条件，移动左指针，最多移动到中间的这个值的位置
        }
        while (array[j] > pivot) {
          j--; // 如果右边的指针的值大于中间值，符合条件，移动右指针，最多移动到中间的这个值的位置
        }
        if (i <= j) { // 如果 i <= j 说明在上边的连个 while 循环中某个地方停住了，交换位置，同时移动指针
          swap(array, i, j);
          i++;
          j--;
        }
      }
      return i;
    }

    function quick(array, left, right) {
      let index;
      if (array.length > 1) {
        index = partition(array, left, right);
        if (left < index - 1) {
          quick(array, left, index - 1);
        }
        if (index < right) {
          quick(array, index, right);
        }
      }
      return array;
    }
    function quickSort(array) {
      return quick(array, 0, array.length - 1);
    }
    let arr = [4, 2, 8]
    console.log(quickSort(arr))
  </script>
</body>

</html>