<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>ceshi</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    #container {
      height: 100vh;
      overflow: auto;
    }
  </style>
</head>

<body>
  <div id='container'>
    <div id='box'>
    </div>
  </div>
  <script>
    // bind 兼容写法
    // if (!Function.prototype.testbind) {
    //   Function.prototype.testbind = function (oThis) {
    //     console.log(this)
    //     if (typeof this !== 'function') {
    //       // closest thing possible to the ECMAScript 5
    //       // internal IsCallable function
    //       throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    //     }

    //     var aArgs = Array.prototype.slice.call(arguments, 1),
    //       fToBind = this,
    //       fNOP = function () { },
    //       fBound = function () {
    //         console.log(this instanceof fNOP)
    //         return fToBind.apply(this instanceof fNOP
    //           ? this
    //           : oThis,
    //           // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
    //           aArgs.concat(Array.prototype.slice.call(arguments)));
    //       };
    //     // 维护原型关系
    //     if (this.prototype) {
    //       // Function.prototype doesn't have a prototype property
    //       fNOP.prototype = this.prototype;
    //     }
    //     fBound.prototype = new fNOP();
    //     // console.log(this instanceof fNOP)

    //     return fBound;
    //   };
    // }

    // var foo = function () {
    //   this.b = 100
    //   return this.a
    // }

    // var func = foo.testbind({a: 1})

    // // console.log(func())
    // console.log(new func())

    // function parenthesesChecker (symbols) {
    //   const stack = []
    //   const opens = '([{'
    //   const closers = ')]}'
    //   let balanced = true
    //   let index = 0
    //   let symbol
    //   let top

    //   while (index < symbols.length && balanced) {
    //     symbol = symbols[index]
    //     if (opens.indexOf(symbol) >= 0) {
    //       stack.push(symbol)
    //     } else if (stack.length === 0) {
    //       balanced = false
    //     } else {
    //       top = stack.pop()
    //       if (!(opens.indexOf(top) === closers.indexOf(symbol))) {
    //         balanced = false
    //       }
    //     }
    //     index++
    //   }
    //   return balanced && !stack.length
    // }
    // console.log(parenthesesChecker('()'))

    class ValuePair {
      constructor(key, value) {
        this.key = key;
        this.value = value;
      }
      toString() {
        return `[#${this.key}: ${this.value}]`;
      }
    }
    // toString
    function defaultToString(item) {
      if (item === null) {
        return 'NULL';
      } else if (item === undefined) {
        return 'UNDEFINED';
      } else if (typeof item === 'string' || item instanceof String) {
        return `${item}`;
      }
      return item.toString();
    }

    class Dictionary {
      constructor(toStrFn = defaultToString) {
        this.toStrFn = toStrFn;
        this.table = {};
      }
      set(key, value) {
        if (key != null && value != null) {
          const tableKey = this.toStrFn(key);
          this.table[tableKey] = new ValuePair(key, value); // 注意这里添加新的属性 table: {name: {key: 'name', value: 123}}
          return true;
        }
        return false;
      }
      get(key) {
        const valuePair = this.table[this.toStrFn(key)];
        return valuePair == null ? undefined : valuePair.value;
      }
      hasKey(key) {
        return this.table[this.toStrFn(key)] != null;
      }
      remove(key) {
        if (this.hasKey(key)) {
          delete this.table[this.toStrFn(key)];
          return true;
        }
        return false;
      }
      values() {
        return this.keyValues().map(valuePair => valuePair.value);
      }
      keys() {
        return this.keyValues().map(valuePair => valuePair.key);
      }
      keyValues() {
        return Object.values(this.table);
      }
      forEach(callbackFn) {
        const valuePairs = this.keyValues();
        for (let i = 0; i < valuePairs.length; i++) {
          const result = callbackFn(valuePairs[i].key, valuePairs[i].value);
          if (result === false) {
            break;
          }
        }
      }
      isEmpty() {
        return this.size() === 0;
      }
      size() {
        return Object.keys(this.table).length;
      }
      clear() {
        this.table = {};
      }
      toString() {
        if (this.isEmpty()) {
          return '';
        }
        const valuePairs = this.keyValues();
        let objString = `${valuePairs[0].toString()}`;
        for (let i = 1; i < valuePairs.length; i++) {
          objString = `${objString},${valuePairs[i].toString()}`;
        }
        return objString;
      }
    }

    class Graph {
      constructor(isDirected = false) {
        this.isDirected = isDirected; // 是否是有方向的
        this.vertices = []; // 存放所有顶点名字
        this.adjList = new Dictionary(); // 存放邻接表
      }
      // 添加新的顶点，实例化后为空
      addVertex(v) {
        if (!this.vertices.includes(v)) {
          this.vertices.push(v);
          this.adjList.set(v, []); // initialize adjacency list with array as well;
        }
      }
      // 建立链接 a <---> b
      addEdge(a, b) {
        if (!this.adjList.get(a)) {
          this.addVertex(a);
        }
        if (!this.adjList.get(b)) {
          this.addVertex(b);
        }
        this.adjList.get(a).push(b); // 将 a -> b
        if (this.isDirected !== true) {
          // 如果是没有方向的 b -> a
          this.adjList.get(b).push(a);
        }
      }
      getVertices() {
        return this.vertices;
      }
      getAdjList() {
        return this.adjList;
      }
      toString() {
        let s = '';
        for (let i = 0; i < this.vertices.length; i++) {
          s += `${this.vertices[i]} -> `;
          const neighbors = this.adjList.get(this.vertices[i]);
          for (let j = 0; j < neighbors.length; j++) {
            s += `${neighbors[j]} `;
          }
          s += '\n';
        }
        return s;
      }
    }

    const graph = new Graph();

    const myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];

    for (let i = 0; i < myVertices.length; i++) {
      graph.addVertex(myVertices[i]);
    }
    graph.addEdge('A', 'B');
    graph.addEdge('A', 'C');
    graph.addEdge('A', 'D');
    graph.addEdge('C', 'D');
    graph.addEdge('C', 'G');
    graph.addEdge('D', 'G');
    graph.addEdge('D', 'H');
    graph.addEdge('B', 'E');
    graph.addEdge('B', 'F');
    graph.addEdge('E', 'I');

    console.log('********* printing graph ***********');

    console.log(graph.toString());
  </script>
</body>

</html>