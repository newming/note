<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>ceshi</title>
</head>
<body>
  <script>
    // bind 兼容写法
    // if (!Function.prototype.testbind) {
    //   Function.prototype.testbind = function (oThis) {
    //     console.log(this)
    //     if (typeof this !== 'function') {
    //       // closest thing possible to the ECMAScript 5
    //       // internal IsCallable function
    //       throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    //     }

    //     var aArgs = Array.prototype.slice.call(arguments, 1),
    //       fToBind = this,
    //       fNOP = function () { },
    //       fBound = function () {
    //         console.log(this instanceof fNOP)
    //         return fToBind.apply(this instanceof fNOP
    //           ? this
    //           : oThis,
    //           // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的
    //           aArgs.concat(Array.prototype.slice.call(arguments)));
    //       };
    //     // 维护原型关系
    //     if (this.prototype) {
    //       // Function.prototype doesn't have a prototype property
    //       fNOP.prototype = this.prototype;
    //     }
    //     fBound.prototype = new fNOP();
    //     // console.log(this instanceof fNOP)

    //     return fBound;
    //   };
    // }

    // var foo = function () {
    //   this.b = 100
    //   return this.a
    // }

    // var func = foo.testbind({a: 1})

    // // console.log(func())
    // console.log(new func())

    // function parenthesesChecker (symbols) {
    //   const stack = []
    //   const opens = '([{'
    //   const closers = ')]}'
    //   let balanced = true
    //   let index = 0
    //   let symbol
    //   let top

    //   while (index < symbols.length && balanced) {
    //     symbol = symbols[index]
    //     if (opens.indexOf(symbol) >= 0) {
    //       stack.push(symbol)
    //     } else if (stack.length === 0) {
    //       balanced = false
    //     } else {
    //       top = stack.pop()
    //       if (!(opens.indexOf(top) === closers.indexOf(symbol))) {
    //         balanced = false
    //       }
    //     }
    //     index++
    //   }
    //   return balanced && !stack.length
    // }
    // console.log(parenthesesChecker('()'))
  </script>
</body>
</html>